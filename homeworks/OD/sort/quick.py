# **Преимущества Quick Sort:**
# - **Быстрота в среднем:** Быстрый сортировщик с временем выполнения O(n log n) в среднем случае.
# - **Дополнительная память:** Обычно сортирует "на месте" (in-place), не требуя дополнительной памяти.
# - **Хорошая локальность данных:** Быстро работает на современных процессорах благодаря хорошей локальности данных.
# - **Обратная совместимость:** Хорошо подходит для больших объемов данных и часто используется в стандартных библиотеках.
#
# **Недостатки Quick Sort:**
# - **Склонность к худшему случаю:** В худшем случае (например, при уже отсортированных данных) время выполнения может стать O(n^2).
# - **Зависимость от выбора опорного элемента:** Эффективность сильно зависит от выбора опорного элемента (лучше использовать случайный выбор или медиану).
# - **Рекурсивная реализация:** Может привести к глубокой рекурсии и стековым переполнениям при очень больших массивах.
#
# ---

### Пример реализации Quick Sort на Python:

def sort(arr):
    if len(arr) <= 1:
        return arr
    else:
        # Выбираем опорный элемент (например, последний)
        pivot = arr[len(arr) // 2]
        # Разделяем на элементы меньше, равные и больше опорного
        less = [x for x in arr if x < pivot]
        equal = [x for x in arr if x == pivot]
        greater = [x for x in arr if x > pivot]
        # Рекурсивно сортируем и объединяем
        return sort(less) + equal + sort(greater)